# Getting Started
{:.no_toc}

{:toc}
{: [start=0] }
* TOC

---

In this tutorial, we will walk through the steps of building a simple Rails app
called *Flipper*. It is essentially a simplified version of the [`Textify`](/demos/textify)
demo that allows you to flip a piece of text upside down:

<%= image_tag "getting-started/flipper.gif" %>

To make things interesting, we will be implementing the core functionality in
Rust using Helix. At the end of the tutorial we will also cover deploying this
app to Heroku.

# Step 0: Install Rust

Before we begin, we need to install Rust using the [rustup](https://www.rustup.rs)
installer:

```plain
$ curl https://sh.rustup.rs -sSf | sh
```

If you already have rustup installed, run this command to ensure you have the
latest version of Rust:

```plain
$ rustup update
```

# Step 1: Create a new Rails project

First, we'll need a new rails project. (If you are integrating Helix into an
existing Rails project, you may skip this step.)

```{~/code/}plain
$ rails new --skip-active-record flipper
```

Since we are not going to need a database for this simple app, we can simplify
things by removing Active Record with the `--skip-active-record` flag. To make
sure things are working properly, let's make sure we can run the Rails server:

```{~/code/flipper/}plain
$ bin/rails server
```

If you visit [http://localhost:3000](http://localhost:3000) in your browser,
you should be greeted by a page similar to this:

<%= image_tag "getting-started/yay-rails.png" %>

Once you have verified that everything is working, exit the Rails server by
pressing **Ctrl+C**.

# Step 2: Generate a Helix crate

To start using Helix, add the `helix-rails` gem to your Gemfile:

```{Gemfile}ruby
source 'https://rubygems.org'

# ...

gem 'helix-rails', '~> 0.5.0'
```

Be sure to run `bundle install` afterwards.

Now that we have Helix installed, we can generate a Helix crate:

```{~/code/flipper/}plain
$ rails generate helix:crate text_transform
```

This will generate a Helix crate called *text_transform*, located in
`crates/text_transform`. A Helix crate is simultaneously a Rust [crate](https://doc.rust-lang.org/book/crates-and-modules.html)
and a Ruby [gem](http://guides.rubygems.org/what-is-a-gem/). This encourages
you to structure your Rust code as a self-contained library separate from your
application code.

Looking at the boilerplate generated by Helix, we can see that it generated a
Rust file for us:

```{~/code/flipper/crates/text_transform/src/lib.rs}rust
#[macro_use]
extern crate helix;

ruby! {
    class TextTransform {
        def hello() {
            println!("Hello form text_transform!");
        }
    }
}
```

This defines a simple Ruby class `TextTransform` with a single class method. To
test this out, we can run `rake irb`, which automatically compiles the Rust
code and puts us into an irb session:

```{~/code/flipper/crates/text_transform/}plain
$ rake irb
>> TextTransform.hello
Hello form text_transform!
=> nil
```

As you can see, we were able to invoke the method (implemented in Rust) from
Ruby. Pretty cool!

# Step 3: Implement the `text_transform` library

Now that we have the boilerplate down, let's implement the `text_transform`
library.

Let's begin by writing some tests using RSpec.

First we will add `rspec` as development dependency:

```{~/code/flipper/crates/text_transform/text_transform.gemspec}ruby
Gem::Specification.new do |s|
  s.name = 'text_transform'
  # ...
  s.add_development_dependency 'rspec', '~> 3.4'
end
```

Be sure to run `bundle install` afterwards.

Then we will add our test:

```{~/code/flipper/crates/text_transform/spec/text_transform_spec.rb}ruby
require "text_transform"

describe "TextTransform" do
  it "can flip text" do
    expect(TextTransform.flip("Hello Aaron (@tenderlove)!")).to eq("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")
  end

  it "can flip the text back" do
    expect(TextTransform.flip("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")).to eq("Hello Aaron (@tenderlove)!")
  end
end
```

As expected, the tests will fail as we have not implemented the `flip` method:

```{~/code/flipper/crates/text_transform/}plain
$ rspec
FF

Failures:

  1) TextTransform can flip text
     Failure/Error: expect(TextTransform.flip("Hello Aaron (@tenderlove)!")).to eq("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")

     NoMethodError:
       undefined method `flip' for TextTransform:Class
     # ./spec/text_transform_spec.rb:5:in `block (2 levels) in <top (required)>'

  2) TextTransform can flip the text back
     Failure/Error: expect(TextTransform.flip("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")).to eq("Hello Aaron (@tenderlove)!")

     NoMethodError:
       undefined method `flip' for TextTransform:Class
     # ./spec/text_transform_spec.rb:9:in `block (2 levels) in <top (required)>'

Finished in 0.00068 seconds (files took 0.13472 seconds to load)
2 examples, 2 failures
```

Now that we have some failing tests, let's implement the missing method (in Rust!):

```{~/code/flipper/crates/text_transform/src/lib.rs}rust
#[macro_use]
extern crate helix;

ruby! {
    class TextTransform {
        def flip(text: String) -> String {
            text.chars().rev().map(|char| {
                match char {
                    '!' => '¬°', '"' => '‚Äû', '&' => '‚Öã', '\'' => '‚Äö', '(' => ')', ')' => '(', ',' => '‚Äò', '.' => 'Àô',
                    '1' => '∆ñ', '2' => '·ÑÖ', '3' => '∆ê', '4' => '„Ñ£', '5' => 'œõ', '6' => '9', '7' => '„Ñ•',
                    '9' => '6', ';' => 'ÿõ', '<' => '>', '>' => '<', '?' => '¬ø',
                    'A' => '‚àÄ', 'B' => 'êêí', 'C' => '‚ÜÉ', 'D' => '‚óñ', 'E' => '∆é', 'F' => '‚Ñ≤', 'G' => '‚ÖÅ',
                    'J' => '≈ø', 'K' => ' û', 'L' => '‚ÖÇ', 'M' => 'W',
                    'P' => '‘Ä', 'Q' => 'Œå', 'R' => '·¥ö', 'T' => '‚ä•', 'U' => '‚à©', 'V' => '·¥ß', 'W' => 'M',
                    'Y' => '‚ÖÑ', '[' => ']', ']' => '[', '^' => 'v', '_' => '‚Äæ',
                    '`' => ',', 'a' => '…ê', 'b' => 'q', 'c' => '…î', 'd' => 'p', 'e' => '«ù', 'f' => '…ü', 'g' => '∆É',
                    'h' => '…•', 'i' => '·¥â', 'j' => '…æ', 'k' => ' û', 'm' => '…Ø', 'n' => 'u',
                    'p' => 'd', 'q' => 'b', 'r' => '…π', 't' => ' á', 'u' => 'n', 'v' => ' å', 'w' => ' ç',
                    'y' => ' é', '{' => '}', '}' => '{',

                    // Flip back
                    '¬°' => '!', '‚Äû' => '"', '‚Öã' => '&', '‚Äö' => '\'', '‚Äò' => ',', 'Àô' => '.',
                    '∆ñ' => '1', '·ÑÖ' => '2', '∆ê' => '3', '„Ñ£' => '4', 'œõ' => '5', '„Ñ•' => '7',
                    'ÿõ' => ';', '¬ø' => '?',
                    '‚àÄ' => 'A', 'êêí' => 'B', '‚ÜÉ' => 'C', '‚óñ' => 'D', '∆é' => 'E', '‚Ñ≤' => 'F', '‚ÖÅ' => 'G',
                    '≈ø' => 'J', '‚ÖÇ' => 'L',
                    '‘Ä' => 'P', 'Œå' => 'Q', '·¥ö' => 'R', '‚ä•' => 'T', '‚à©' => 'U', '·¥ß' => 'V',
                    '‚ÖÑ' => 'Y', '‚Äæ' => '_',
                    '…ê' => 'a', '…î' => 'c', '«ù' => 'e', '…ü' => 'f', '∆É' => 'g',
                    '…•' => 'h', '·¥â' => 'i', '…æ' => 'j', ' û' => 'k', '…Ø' => 'm',
                    '…π' => 'r', ' á' => 't', ' å' => 'v', ' ç' => 'w',' é' => 'y',

                    _ => char,
                }
            }).collect()
        }
    }
}
```

The `flip` method takes a string as input, split it into characters, map each
character into its "upside down lookalike" and join them back up into a new
string.

Now that we have implemented the method, let's run the tests again:

```{~/code/flipper/crates/text_transform/}plain
$ rspec
FF

Failures:

  1) TextTransform can flip text
     Failure/Error: expect(TextTransform.flip("Hello Aaron (@tenderlove)!")).to eq("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")

     NoMethodError:
       undefined method `flip' for TextTransform:Class
     # ./spec/text_transform_spec.rb:5:in `block (2 levels) in <top (required)>'

  2) TextTransform can flip the text back
     Failure/Error: expect(TextTransform.flip("¬°(«ù åol…π«ùpu«ù á@) uo…π…ê‚àÄ oll«ùH")).to eq("Hello Aaron (@tenderlove)!")

     NoMethodError:
       undefined method `flip' for TextTransform:Class
     # ./spec/text_transform_spec.rb:9:in `block (2 levels) in <top (required)>'

Finished in 0.00068 seconds (files took 0.13472 seconds to load)
2 examples, 2 failures
```

Hm, it is not seeing the `flip` method we just implemented. This is because
since Rust is a *compiled-language*, we would have to re-compile our code after
making any changes:

```{~/code/flipper/crates/text_transform/}plain
$ rake build
cargo rustc --release -- -C link-args=-Wl,-undefined,dynamic_lookup
   Compiling text_transform v0.1.0 (file:///private/tmp/flipper/crates/text_transform)
    Finished release [optimized] target(s) in 0.95 secs
```

Now if we run the tests again, everything will work as expected:

```{~/code/flipper/crates/text_transform/}plain
$ rspec
..

Finished in 0.00348 seconds (files took 0.12317 seconds to load)
2 examples, 0 failures
```

To avoid needing to manually recompile, we can wrap this in a rake task and
make `rake build` its dependency:

```{~/code/flipper/crates/text_transform/Rakefile}ruby
require 'bundler/setup'
require 'rspec/core/rake_task'
import 'lib/tasks/helix_runtime.rake'

RSpec::Core::RakeTask.new(:spec) do |t|
  t.verbose = false
end

task :spec => :build
task :default => :spec
```

That way, running `rake spec` will always ensure the Rust code is built (and
up-to-date) before running your tests, just like the built-in `rake irb` task.

# Step 4: Putting it all together

Now that we have built a library to do the heavily-lifting for us, we wire
everything up inside our Rails app.

First let's create the route:

```{~/code/flipper/config/routes.rb}ruby
Rails.application.routes.draw do
  resources :flips, path: '/', only: [:index, :create]
end
```

Then we will create the controller:

```{~/code/flipper/app/controllers/flips_controller.rb}ruby
class FlipsController < ApplicationController
  def index
    @text = params[:text] || "Hello world!"
  end

  def create
    @text = TextTransform.flip(params[:text])
    render :index
  end
end
```

And finally the template:

```{~/code/flipper/app/views/flips/index.html.erb}plain
<h1>Flipper</h1>

<%%= form_tag do %>
  <%%= text_field_tag :text, @text %>
  <%%= submit_tag "Flip!" %>
<%% end %>
```

After starting the Rails server with the `rails server` command, you should
have a working *Flipper* app waiting for you at [http://localhost:3000](http://localhost:3000):

<%= image_tag "getting-started/flipper.gif" %>

As you can see, with pretty minimal effort, we were able to crate a Ruby native
extension written in Rust using Helix, and integrate it into our Rails app.

# Step 5: Deploy to Heroku

Finally, we will deploy our Flipper app to Heroku.

First, you will need to create a [Heroku account](https://signup.heroku.com)
and install the [Heroku CLI tools](https://devcenter.heroku.com/articles/heroku-cli).

Then, we will need to create a Heroku app:

```{~/code/flipper/}plain
$ heroku create
```

Since *Flipper* is both a Ruby and a Rust app, we will need to set up the
buildpacks manually:

```{~/code/flipper/}plain
$ heroku buildpacks:add https://github.com/hone/heroku-buildpack-rust
$ heroku buildpacks:add heroku/ruby
```

These commands adds the [Rust buildpack](https://github.com/hone/heroku-buildpack-rust),
which makes the Rust compiler available, as well as the regular Ruby buildpack
that knows how to configure a Rails app.

Finally, we can deploy the app to Heroku:

```{~/code/flipper/}plain
$ git push heroku master
```

With that, you should have a working *Flipper* app ‚Äì powered by Rust, running
instead a Rails app ‚Äì up and running on the Internet. Congratulations!

# Further reading

* [Flipper source code](https://github.com/tildeio/helix-flipper)
* [Helix Demos](/demos)
* [Helix Documentation](/documentation)
